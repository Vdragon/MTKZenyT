#!/bin/bash

function MTKZenyTux() {

    echo -e "#################################"
    echo -e "### ${title_welcome} ###"
    echo -e "#################################"

    manage_colors
    test_config_file
    build_vars

    write_file "log" "#################################################"
    write_file "log" "### ### ### ${title_welcome} ### ### ###"
    write_file "log" "#################################################"

    verify_installed

    detect_device

    display_menu

}

function BACKUP() {

    write_file "log" "${NOW} ### $FUNCNAME: Will try to backup your device!"

    in_array "${GUI}" "${GUIS[@]}";
    if [[ $? -eq 1 ]]; then

        display_feature_with_gui "${FUNCNAME}"

    else

        if [[ "$(adb_whoami)" == "root" ]]; then

            # obtain dir to save
            if [[ -z "${DIR_SVG}" ]]; then

                #DIR_SVG=$(choose_directory "d" "${title_dir_svg}")
                choose_directory "d" "${title_dir_svg}" && DIR_SVG="${DIR_CHOOSED}"
                write_file "cfg" "DIR_SVG" "${DIR_SVG}"

            fi

            write_file "log" "${NOW} *** $FUNCNAME: DIR_SVG=${DIR_SVG}"

            # mkdir dated into DIR_SVG !
            if [[ -d "${DIR_SVG}" ]]; then

                make_dir_dated

                if [[ -d "${DIR_SVG_DATED}" ]]; then

                    adb_restart_server
                    adb_read_partitions

                    if [[ -f "${FILE_PARAM}" ]]; then

                        file_to_array_mtd

                        display_files

                        #convert_str_to_array
                        if [[ "${files}" ]]; then
                            FILES_CHOOSED=($(explode " " "${files}"))
                        fi

                        adb_save_partitions

                    fi

                fi

            fi

        else

            mssg=$(printf "%s" "${text_su_inactive}\n${text_unroot_stop}\n")
            display_error "${mssg}"

        fi

    fi

}

function CUSTOM() {

    display_feature_disable "${FUNCNAME}"

}

function EXIT() {

    adb kill-server
    display_mssg "n" "${text_goodbye}" "${title_goodbye}" "1"
    destruct
    exit 0

}

function FLASH() {

    write_file "log" "${NOW} ### $FUNCNAME: Will try to flash your device!"

    in_array "${GUI}" "${GUIS[@]}";
    if [[ $? -eq 1 ]]; then

        display_feature_with_gui "${FUNCNAME}"

    else

        adb_restart_server
        adb_read_partitions

        if [[ -f "${FILE_PARAM}" ]]; then

            file_to_array_mtd

            display_files

            if [[ "${files}" ]]; then files=($(explode " " "${files}")); fi

            if [[ -n "${files[@]}" ]]; then
                for file in "${files[@]}"; do
                    if [[ -n "${file}" ]]; then
                        if [[ "${DIALOG}" -ne 0 ]]; then file="${MTD_NAME[${file}]}"; fi
                        choose_directory "f" "${text_choose_file}${file}";
                        if [[ -n "${FILE_CHOOSED}" ]]; then FILES_CHOOSED["${file}"]="${FILE_CHOOSED}"; fi
                    fi
                done
            else
                display_error "!!! ERROR: array files is empty !!!"
            fi

            echo "files: ${!FILES_CHOOSED[@]} ${FILES_CHOOSED[@]}"
            adb_flash_partitions

        fi

    fi

}

function REBOOT() {

    adb_reboot

}

function ROOT() {

    adb_restart_server

    root_to_recovery

}

function UNROOT() {

    adb_restart_server

    if [[ "${vid}" == "${VID[0]}" ]]; then

        unroot_to_recovery

    else

        unroot_to_system

    fi

}

function array_key_exists() {

    # equivalent to PHP array_key_exists
    # call: if [[ $(array_key_exists key array) -eq 0 ]]; then echo "key exists!"; fi

    local key="$1" IFS=" "; shift; read -a array <<< "$@"
    if [[ "${array[$key]}" ]]; then return 0; return 1; fi

    unset array key IFS

}

function array_search() {

    # equivalent to PHP array_search
    # call: array_search needle array

    local needle="$1" IFS=" "; shift; read -a array <<< "$@"

    for (( i=0; i < $(count "${array[*]}"); i++ )); do
        if [[ "${array[$i]}" == "${needle}" ]]; then echo "$i"; fi
    done
    return 1

    unset array needle IFS

}

function build_vars() {

    if [[ -n "${MENU_NAME[@]}" ]]; then

        for name in "${MENU_NAME[@]}"; do
            # fill array MENU_TEXT...
            var="text_menu_$name"
            MENU_TEXT["${name}"]="${!var}"
            unset var

        done

    fi

}

function choose_directory() {

    local index="$1" name="$2"

    if [[ "${DIALOG}" -ne 0 ]]; then

        case "${index}" in
            "d") DIR_CHOOSED=$(dialog_select_dir "${name}") ;;
            "f")
                FILE_CHOOSED=$(dialog_select_file "${name}")

                if [[ -z "${FILE_CHOOSED}" ]]; then
                    display_error "${text_error_not_files} : ${name}"
                    choose_directory "${index}" "${name}"
                fi
            ;;
        esac

    elif [[ "${ZENITY}" -ne 0 ]]; then

        if [[ "${index}" == "d" ]]; then
            DIR_CHOOSED=$(zenity_directory "${index}" "${name}");
        else

            FILE_CHOOSED=$(zenity_directory "${index}" "${name}");

            if [[ -z "${FILE_CHOOSED}" ]]; then
                display_error "${text_error_not_files} : ${name}"
                choose_directory "${index}" "${name}"
            fi
        fi

    else

        read -p "${name}" DIR_CHOOSED

    fi

    unset index name

    write_file "log" "${NOW} ### $FUNCNAME: ${DIR_CHOOSED}${FILE_CHOOSED}"

}

function chr() {

    [ "$1" -lt 256 ] || return 1
    printf "%s" "\\$(printf '%03o' "$1")"

}

function convert_str_to_array() {

    write_file "log" "${NOW} ### $FUNCNAME: string: ${files}"

    x=0
    for file in $files; do files[$x]="$file"; let x=x+1; done
    unset x

    write_file "log" "${NOW} ### $FUNCNAME: array: ${files[*]}"

}

function count() {

    # egual PHP count
    # call: count array
    local IFS=" "; read -a array <<< "$*"

    if [[ -n "${#array[@]}" ]]; then echo "${#array[*]}"; else return 1; fi

    unset IFS array

}

function delete_dir() {

    if [[ -d "$1" ]]; then rm -rf "$1"; fi

}

function destruct() {

    write_file "log" "${NOW} ### $FUNCNAME: Destruct variables"

    if [[ -d "${SCRIPT_TMP_DIR}" ]]; then rm -rf "${SCRIPT_TMP_DIR}"; fi

    unset DIALOG FILE_TMP ZENITY
    unset archive choice mssg

    write_file "log" "##################################################"
    write_file "log" "### ### ### $0 ENDED ! ### #### ###"
    write_file "log" "##################################################"

}

function detect_device() {

    if [[ (( "${GUI}" != "z" && "${GUI}" != "zenity" )) ]]; then
        display_mssg "n" "${text_detect_dev}" "" "1";
    fi

    for (( x=0; x < $(count "${VID[@]}") ; x++ )); do
        lsusb=$(lsusb | egrep "${VID[$x]}")

        if [[ "${lsusb}" ]]; then
            pid=${PID[$x]}
            vid=${VID[$x]}
            break;
        fi

        unset lsusb
    done

    if [[ -z "${pid}" ]]; then

        display_error "${text_dev_unrecognized}\n"
        display_mssg "n" "${text_exit}"

        # if GUI=0|no then display press any key
        #in_array "${GUI}" "${GUIS[@]}"
        #if [[ $? -eq 0 ]]; then press_any_key; fi

        EXIT

    else

        local mode=""

        display_detected "${text_VendorID}" "${vid}"
        display_detected "${text_ProductID}" "${pid}"

        if [[ "${vid}" == "${VID[0]}" ]]; then
            mode="Mode: Recovery"
        else
            mode="Mode: Session"
        fi

        display_detected "${mode}"

        if [[ "${DIALOG}" -ne 0 ]]; then
            mssg="$(printf "%s" "\Z${bold}\Z${green}${text_VendorID}\n${text_ProductID}\n${mode}\Z${neutral}\Z${unbold}")"
            mssg="$(printf "${mssg}" "${vid}" "${pid}")";
            display_mssg "n" "${mssg}";
        elif [[ "${ZENITY}" -ne 0 ]]; then
            mssg="$(printf "%s" "<span color=\"${green}\"><b>${text_VendorID}\n${text_ProductID}\n${mode}</b></span>")"
            mssg="$(printf "${mssg}" "${vid}" "${pid}")";
            display_mssg "i" "${mssg}" "${text_detect_dev}" "${title_detect_dev}";
        fi

        if [[ "${mssg}" ]]; then
            unset mssg
        fi

    fi

    write_file "log" "${NOW} ### $FUNCNAME: VID:${vid} and PID:${pid} "

}

function dl_file() {

    # call: dl_file URL FILE_NAME

    mssg=$(printf "${text_dl_file}\n" "$1"); display_mssg "n" "${mssg}"

    curl "$1" > "$2"

    if [[ $? -ne 0 ]]; then
        mssg=$(printf "${text_error_dl}" "$2")
        display_error "${mssg}"

        write_file "log" "${NOW} ### $FUNCNAME: Error to download file: $2 - from: $1"

        EXIT
    fi

}

function dl_yourself() {

    # call: dl_yoursel FILE_NAME

    mssg="$(printf "${text_dl_yourself}\n" "$1")"
    mssg="$(printf "${text_into_tools}\n" "${DIR_TOOLS}")"
    mssg="${mssg} ${text_exit_relaunch}"
    display_mssg "i" "${mssg}"

    write_file "log" "${NOW} ### $FUNCNAME: Need to download yourself the file: $1"

    EXIT

}

function explode() {

    # call: array=("$(explode $delimiter $string)")
    # equivalent PHP explode
    local delimiter="$1" string="$2"

    write_file "log" "${NOW} ### $FUNCNAME: string: ${string}"

    local IFS="${delimiter}"; shift; read -a array <<< "${string}"

    if [[ -z "${array[@]}" ]]; then return 1; fi
    echo "${array[@]}"

    write_file "log" "${NOW} ### $FUNCNAME: array: ${array[*]}"

}

function extract_archive_zip() {

    if [[ -d "${DIR_SSU_UPD}" ]]; then

        display_mssg "q" "${text_dir_ssu_upd}"

        if [[ "${ZENITY}" -ne 0 ]]; then
            REPLY=$?
        elif [[ "${DIALOG}" -ne 0 ]]; then
            REPLY="${read}"
        fi

        case "${REPLY}" in
            o|O|y|Y|0)
                sleep 1 ;;
            n|N|1)
                delete_dir "${DIR_SSU_UPD}"; sleep 3 ;;
            *)
                display_error "${text_choice_invalid}"
                press_any_key
                extract_archive_zip
            ;;
        esac

    fi

    if [[ ! -d "${DIR_SSU_UPD}" ]]; then

        if [[ -f "${FILE_SSU_ZIP}" ]]; then

            mssg=$(printf "\n${text_unzip}\n" "${FILE_SSU_ZIP}")
            display_mssg "n" "${mssg}"
            unzip -o "${DIR_UNZIP}" -d "${DIR_UNZIP}"

            if [[ $? -eq 0 ]]; then
                mssg="$(printf "${text_unzip_ok}" "${FILE_SSU_ZIP}")"
                display_mssg "n" "${mssg}"

                write_file "log" "${NOW} ### $FUNCNAME: Unzip OK: ${DIR_TOOLS}UPDATE-SuperSU-${SSU_VERSION}"
            else
                mssg="$(printf "${text_error_unzip}" "$?" "${FILE_SSU_ZIP}")"
                display_error "${mssg}"

                write_file "log" "${NOW} ### $FUNCNAME: Unzip KO: ${DIR_TOOLS}UPDATE-SuperSU-${SSU_VERSION}"

                press_any_key
                EXIT
            fi

        fi

    fi

}

function extract_info_system() {

    if [[ -f "${FILE_PARAM}" ]]; then

        CMDLINE=$(egrep "^$1" "${FILE_PARAM}" | sed 's/\r$//')

        local IFS=": "; shift; read -a params <<< "${CMDLINE}"

        INFO_MAP["$1"]=${params[4]}
        mssg=$(printf "${text_system_info}\n" "$1" "${INFO_MAP[$1]}" )
        display_mssg "n" "${mssg}"

        write_file "log" "${NOW} ### $FUNCNAME: $1 == ${INFO_MAP[$1]}"

    fi

}

function file_to_array_mtd() {

    # init arrays mtd
    MTD_NAME=()
    MTD_SIZE=()
    MTD_ADDR=()
    MTD_TYPE=()
    MTD_MAP=()
    MTD_SIZE_DEC=()
    MTD_ADDR_DEC=()
    MTD_SIZE_BLOCK=()
    MTD_ADDR_BLOCK=()

    x=0
    # read file param into array
    while read line; do

        if [[ $x -ge 1 && $x -le 22 ]]; then

            local IFS=" "; shift; read -a mtd <<< "$(echo "${line}" | sed 's/\r$//' | tr -s ' ')"

            # create arrays dynamic 'mtd_$info_name[value]'
            in_array "${mtd[0]}" "${PART_NOBCKP[@]}"
            if [[ $? -ne 0 ]]; then

                MTD_NAME[$x]="${mtd[0]}"
                MTD_SIZE[$x]="${mtd[1]}"
                MTD_ADDR[$x]="${mtd[2]}"
                MTD_TYPE[$x]="${mtd[3]}"
                MTD_MAP[$x]="${mtd[4]}"
                MTD_SIZE_DEC[$x]=$(hexdec "${MTD_SIZE[$x]}")
                MTD_ADDR_DEC[$x]=$(hexdec "${MTD_ADDR[$x]}")
                MTD_SIZE_BLOCK[$x]=$(bc <<< "${MTD_SIZE_DEC[$key]} / ${INODE}")
                MTD_ADDR_BLOCK[$x]=$(bc <<< "${MTD_ADDR_DEC[$key]} / ${INODE}")

            fi
            unset mtd

        fi

        let x=x+1;

    done < "${FILE_PARAM}"
    unset x

    # reindex mtd arrays
    MTD_NAME=("${MTD_NAME[@]}")
    MTD_SIZE=("${MTD_SIZE[@]}")
    MTD_ADDR=("${MTD_ADDR[@]}")
    MTD_TYPE=("${MTD_TYPE[@]}")
    MTD_MAP=("${MTD_MAP[@]}")
    MTD_SIZE_DEC=("${MTD_SIZE_DEC[@]}")
    MTD_ADDR_DEC=("${MTD_ADDR_DEC[@]}")
    MTD_SIZE_BLOCK=("${MTD_SIZE_BLOCK[@]}")
    MTD_ADDR_BLOCK=("${MTD_ADDR_BLOCK[@]}")

    write_file "log" "${NOW} ### $FUNCNAME: Create mtd array: MTD_NAME[ ${MTD_NAME[*]} ]"

}

function file_stat() {

    local file="$1"
    local -i int

    if [[ -f "${file}" ]]; then int=$(stat -c "%s" ${file} | sed 's/\r$//'); fi

    echo ${int}

}

function get_info_system() {

    # call: get_info_system partition_name

    adb_read_partitions

    extract_info_system "$1"

}

function hexdec() {

    echo "$(($1))"

}

function in_array() {

    # equivalent to PHP in_array
    # call: in_array needle array

    local i=0 needle="$1" IFS=" "; shift; read -a array <<< "$@"

    while [ $i -le ${#array[@]} ]; do
        if [[ "${array[$i]}" == "${needle}" ]]; then return 0; fi # true
        let i=i+1
    done
    return 1

    unset i needle IFS array

}

function make_dir_dated() {

    if [[ -d "${DIR_SVG}" ]]; then

        DIR_SVG_DATED="${DIR_SVG}/${vid}:${pid}_${NOW}"

        if [[ ! -d "${DIR_SVG_DATED}" ]]; then
            mkdir "${DIR_SVG_DATED}" && display_detected "${text_dir_ok}" "${DIR_SVG_DATED}"
        fi

        write_file "log" "${NOW} ### $FUNCNAME: DIR_SVG_DATED: ${DIR_SVG_DATED}"

    fi

}

function manage_colors() {

    i=0

    while [ $i -le $(count ${COLORS_NAME[@]}) ]; do

        if [[ "${DIALOG}" -ne 0 ]]; then

            if [[ -n "${COLORS_NAME[$i]}" ]]; then
                export declare "${COLORS_NAME[$i]}"="${COLORS_VALUE[$i]}"
            fi

        elif [[ "${ZENITY}" -ne 0 ]]; then

            if [[ -n "${COLORS_NAME[$i]}" ]]; then
                export declare "${COLORS_NAME[$i]}"="${COLORS_NAME[$i]}"
            fi

        else

            if [[ -n "${COLORS_NAME[$i]}" ]]; then
                export declare "${COLORS_NAME[$i]}"="3${COLORS_VALUE[$i]}"
            fi

        fi

        let i=i+1

    done

    unset i

}

function manage_fonts() {

    manage_colors

    i=0

    while [ $i -le $(count ${COLORS_NAME[@]}) ]; do

        if [[ "${DIALOG}" -ne 0 ]]; then

            neutral="n"
            bold="b"; unbold="B"
            underline="u"; ununderline="U"
            esc_seq="\Z"

        elif [[ "${ZENITY}" -ne 0 ]]; then

            neutral="</span>"
            bold="<b>"; unbold="</b>"
            underline="<u>"; ununderline="</u>"
            esc_seq=""

        else

            neutral="0"
            bold="1"; unbold="${neutral}"
            underline="4"; ununderline="${neutral}"
            esc_seq="\e["

        fi

        let i=i+1

    done

    unset i

}

function modify_system() {

    if [[ "${vid}" == "${VID[0]}" ]]; then

        adb_root_system

    fi

}

function press_any_key() {

    read -p "${text_press_key}" -n1 -s
    echo " "

}

function read_config() {

    search=$(grep "$1" "${PWD}/${CONFIG}")
    if [[ -n "${search}" ]]; then

        #if [[ "$(grep "^DIR" <<< "${search}")" || "$(grep "^BCKP" <<< "${search}")" ]]; then
        s1=$(grep "^DIR" <<< "${search}"); s2=$(grep "^BCKP" <<< "${search}")
        if [[ "$s1" || "$s2" ]]; then

            # if ultimate character of search isn't '/' and not '=', add-it '/'
            s3=$(grep "./$" <<< "${search}"); s4=$(grep ".=$" <<< "${search}")
            if [[ ! "$s3" && ! "$s4" ]]; then
                search="${search}/";
            fi
            unset s3 s4

        fi
        unset s1 s2

        echo "${search#*=}"

    fi
    unset search

}

function reboot_recovery() {

    if [[ "${vid}" != "${VID[0]}" ]]; then

        display_error "\n${text_dev_not_recovery}\n"
        display_mssg "q" "${text_ask_restart}"

        if [[ "${ZENITY}" -ne 0 ]]; then

            REPLY=$?

        elif [[ "${DIALOG}" -ne 0 ]]; then

            REPLY="${read}"

        fi

        while true; do
            case $REPLY in
                y|Y|o|O|0)
                    steps_to_recovery
                    break
                ;;
                n|N|1)
                    mssg="${text_reboot_yoursel}\n${text_exit_reboot}"
                    display_mssg "i" "${mssg}"

                    EXIT
                ;;
                *)
                    display_error "${text_choice_invalid}"
                    press_any_key
                    reboot_recovery
                ;;
            esac
        done

    else

        display_mssg "n" "\n${text_into_recovery}\n"; sleep 1

    fi

}

function reboot_system() {

    display_mssg "i" "${text_verify_errors}"

    display_mssg "q" "${text_ask_reboot_system}"

    if [[ "${ZENITY}" -ne 0 ]]; then

        REPLY=$?

    elif [[ "${DIALOG}" -ne 0 ]]; then

        REPLY="${read}"

    fi

    while true; do
        case $REPLY in
            y|Y|o|O|0)
                adb_reboot_system
                break
            ;;
            n|N|1)
                mssg=$(printf "${text_reboot_yourself}\n${text_exit}")
                display_mssg "i" "${mssg}"

                EXIT
            ;;
            *)
                display_error "${text_choice_invalid}"
                press_any_key
                reboot_system
            ;;
        esac
    done

}

function root_to_recovery() {

    reboot_recovery

    verify_ssu_exists

    #get_info_system "android"
    adb_read_partitions

    if [[ -f "${FILE_PARAM}" ]]; then

        file_to_array_mtd

        adb_root_system

        reboot_system

    fi

}

function save_rom() {

    if [[ "${ZENITY}" -ne 0 ]]; then
        (
            adb_save_partitions
        ) | zenity_progress "${text_save_tablet}" "${title_save_tablet}"
    else
        adb_save_partitions
    fi

}

function steps_to_recovery() {

    adb_reboot_recovery

    display_mssg "n" "${press_any_key_after_reboot}"
    press_any_key

    detect_device

    choice="UNROOT"
    #$0

}

function test_config_file() {

    display_mssg "n" "\n${text_detect_cfg}"

    if [[ -f "${CONFIG}" && -r "${CONFIG}" ]]; then

        LOG=$(read_config "LOG") && display_detected "LOG=${LOG}"
        BCKP_PHONE=$(read_config "BCKP_PHONE") && display_detected "BCKP_PHONE=${BCKP_PHONE}"
        CFG=1 && display_detected "CFG=1"
        DIR_SVG=$(read_config "DIR_SVG") && display_detected "DIR_SVG=${DIR_SVG}"
        GUI=$(read_config "GUI") && display_detected "GUI=${GUI}"

    else

        mssg="$(printf "${text_error_file}\n" "${CONFIG}")"
        display_error "${mssg}"

        press_any_key
        EXIT

    fi

}


function unroot_to_recovery() {

    reboot_recovery

    # manage datas into /data
    #get_info_system "usrdata"

    #if [[ -z $(adb_verify_mount "data") ]]; then mount "data"; fi
    if [[ -z $(adb_verify_mount "data") ]]; then adb_mount_partition "data"; fi

    adb_delete_su_datas

    adb_umount_partition "data"

    # manage datas into /system
    #get_info_system "android"

    #if [[ -z $(adb_verify_mount "system") ]]; then mount "system"; fi
    if [[ -z $(adb_verify_mount "system") ]]; then adb_mount_partition "system"; fi

    adb_delete_supersu

    adb_delete_su_system

    adb_umount_partition "system"

    mssg=$(printf "${text_unroot_end}\n${text_verify_errors}\n")
    display_mssg "n" "${mssg}"

}

function unroot_to_system() {

    ##id=$(${adb} shell su -c busybox id -un | sed 's/\r$//'); display_detected "${id}"
    whoami="$(adb_whoami)"; display_detected "id: ${whoami}"

    if [[ "${whoami}" == "root" ]]; then

        adb_mount_partition "w"

        adb_delete_su_datas

        adb_delete_supersu

        adb_delete_su_system

        mssg=$(printf "${text_unroot_end}\n${text_verify_errors}\n")
        display_mssg "n" "${mssg}" "" "1"

        sleep 3

        adb_mount_partition "r"

    else

        mssg=$(printf "%s" "${text_su_inactive}\n${text_unroot_stop}\n")
        display_error "${mssg}"

        in_array "${GUI}" "${GUIS[@]}"
        if [[ $? -eq 0 ]]; then press_any_key; fi

    fi

    unset id

}

function verify_ssu_exists() {

    if [[ ! -f "${FILE_SSU_ZIP}" ]]; then

        mssg=$(printf "\n${text_app_inexistant}\n" "${SuperSU}")
        mssg="${mssg}"$(printf "${text_app_dl}\n" "${SuperSU}" "${URL_SUPERSU}")
        mssg="${mssg}"$(printf "\n${text_ask_dl} ${text_yes_no}")

        display_mssg "q" "${mssg}" ""

        if [[ "${ZENITY}" -ne 0 ]]; then

            REPLY=$?

        elif [[ "${DIALOG}" -ne 0 ]]; then

            REPLY="${read}"

        fi

        while true; do
            case $REPLY in
                y|Y|o|O|0)
                    dl_file "${DL_SUPERSU}" "${FILE_SSU_ZIP}"
                    break
                ;;
                n|N|1)
                    dl_yourself "${SuperSU}"
                ;;
                *)
                    display_error "${text_choice_invalid}"
                    verify_ssu_exists
                ;;
            esac
        done


        verify_archive

    else

        display_mssg "n" "\n${text_ssu_exists}"

        verify_archive

    fi

}

function verify_archive() {

    if [[ -f "${FILE_SSU_ZIP}" ]]; then

        local key="$(array_search "${SSU_VERSION}" "${STATS_SSU_VERSION[@]}")"
        local stat="$(stat -c "%s" "${FILE_SSU_ZIP}")"

        if [[ "${stat}" -ne "${STATS_SSU_SIZE[${key}]}" ]]; then

            mssg="$(printf "${text_error_zip_ssu}" "${stat}" "${STATS_SSU_SIZE[${key}]}")"
            display_error "${mssg}"

            dl_yourself

        else

            extract_archive_zip

        fi

    fi

}

function verify_installed() {

    mssg=$(printf "\n${text_verify_installed}\n")
    display_mssg "i" "${mssg}"
    sleep 1

    if [[ "${GUI}" ]]; then

        GUI=$(awk '{print tolower($0)}' <<< ${GUI});
        display_detected "GUI: ${GUI}"

    fi

    in_array "${GUI}" "${GUIS[@]}"
    if [[ $? -eq 0 ]]; then

        # verify if dialog is installed
        if [[ (( "${GUI}" == "d" || "${GUI}" == "dialog" )) && -x $(which dialog) ]]; then
            DIALOG=1
            ZENITY=0

            dialog=$(which dialog)

        fi

        # verify if zenity is installed.
        if [[ (( "${GUI}" == "z" || "${GUI}" == "zenity" )) && -x $(which zenity) ]]; then
            DIALOG=0
            ZENITY=1

            zenity=$(which zenity)

        fi

        #DIALOG=1
        #ZENITY=0

    fi

    manage_fonts

    if [[ "${DIALOG}" -eq 1 ]]; then
        display_detected "${text_ok_tools}" "Dialog"
        write_file "log" "${NOW} *** $FUNCNAME: Dialog: Yes!"
    fi

    if [[ "${ZENITY}" -eq 1 ]]; then
        display_detected "${text_ok_tools}" "Zenity"
        write_file "log" "${NOW} *** $FUNCNAME: Zenity: Yes!"
    fi

    # adb
    if [[ ! -x $(which adb) ]]; then
        display_error "\n${text_error_not_tools}" "ADB"
        write_file "log" "${NOW} *** $FUNCNAME: adb: Boo!"
        EXIT
    else
        display_detected "${text_ok_tools}" "ADB"
        write_file "log" "${NOW} *** $FUNCNAME: adb: Yes!"
        #adb=$(which adb)
    fi

    # Make dir tmp
    if [[ ! -d "${SCRIPT_TMP_DIR}" ]]; then mkdir "${SCRIPT_TMP_DIR}"; fi

}


function write_file() {

    case $1 in
        "cfg") sed -i -e "#$2=.*# s##$2=$3#g" "${CONFIG}" ;;
        "log") [[ "${LOG}" -eq 1 ]] && echo "$2" >> "${PWD}/logs/${DAY}.log" ;;
    esac

}
